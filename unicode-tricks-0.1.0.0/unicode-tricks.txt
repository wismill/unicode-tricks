-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Functions to work with unicode blocks more convenient.
--   
--   A package that makes rendering of frames, blocks, subscript and
--   superscript more convenient.
@package unicode-tricks
@version 0.1.0.0


-- | Unicode has 2-by-2 blocks, this module aims to make it more convenient
--   to render such blocks.
module Data.Char.Block

-- | A data type that determines the state of the <i>row</i> in a block. it
--   determines the left and the right part of the row of the block.
data Row a
Row :: a -> a -> Row a

-- | The left part of a row of the block.
[left] :: Row a -> a

-- | The right part of the row of the block.
[right] :: Row a -> a

-- | A data type that determines the state of the four subparts of the
--   block.
data Block a
Block :: Row a -> Row a -> Block a

-- | The upper part of the block.
[upper] :: Block a -> Row a

-- | The lower part of the block.
[lower] :: Block a -> Row a

-- | Convert the given <a>Block</a> value to a block character in unicode.
--   <a>True</a> means that part is filled, and <a>False</a> means the part
--   is not filled.
filled :: Block Bool -> Char
instance Data.Traversable.Traversable Data.Char.Block.Block
instance GHC.Show.Show a => GHC.Show.Show (Data.Char.Block.Block a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Char.Block.Block a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Char.Block.Block a)
instance GHC.Base.Functor Data.Char.Block.Block
instance Data.Foldable.Foldable Data.Char.Block.Block
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Char.Block.Block a)
instance Data.Traversable.Traversable Data.Char.Block.Row
instance GHC.Show.Show a => GHC.Show.Show (Data.Char.Block.Row a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Char.Block.Row a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Char.Block.Row a)
instance GHC.Base.Functor Data.Char.Block.Row
instance Data.Foldable.Foldable Data.Char.Block.Row
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Char.Block.Row a)
instance GHC.Base.Applicative Data.Char.Block.Block
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Data.Char.Block.Block a)
instance GHC.Base.Applicative Data.Char.Block.Row
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Data.Char.Block.Row a)


-- | A frame is represented as a pair of horizontal and vertical lines.
--   These can be any items, but currently only booleans and weight objects
--   are covered to convert the item to a corresponding character.
module Data.Char.Frame

-- | The weights of the frame lines, these can be <a>Empty</a>,
--   <a>Light</a> or <a>Heavy</a>.
data Weight

-- | The frame does not contain such line.
Empty :: Weight

-- | The frame contains such line.
Light :: Weight

-- | The frame contains such line, in <i>boldface</i>.
Heavy :: Weight

-- | A data type that determines the state of the <i>horizontal</i> lines
--   of the frame (<a>left</a> and <a>right</a>).
data Horizontal a
Horizontal :: a -> a -> Horizontal a

-- | The state of the left line of the frame.
[left] :: Horizontal a -> a

-- | The state of the right line of the frame.
[right] :: Horizontal a -> a

-- | A data type that determines the state of the <i>vertical</i> lines of
--   the frame (<a>up</a> and <a>down</a>).
data Vertical a
Vertical :: a -> a -> Vertical a

-- | The state of the line in the up direction of the frame.
[up] :: Vertical a -> a

-- | The state of the line in the down direction of the frame.
[down] :: Vertical a -> a

-- | A data type that specifies the four lines that should (not) be drawn
--   for the frame.
data Parts a
Parts :: Vertical a -> Horizontal a -> Parts a

-- | A type synonym that makes it more convenient to work with a
--   <a>Parts</a> object that wraps <a>Bool</a>s. Usually <a>True</a> means
--   it should draw a line, and <a>False</a> that there is no line in that
--   direction.
type Simple = Parts Bool

-- | A type synonym that makes it more convenient to work with a
--   <a>Parts</a> object that wraps <a>Weight</a> objects. These specify
--   the weight .
type Weighted = Parts Weight

-- | A pattern that makes pattern matching and expressions with
--   <a>Parts</a> more convenient.
pattern Frame :: a -> a -> a -> a -> Parts a

-- | Convert a <a>Simple</a> frame to a corresponding <a>Char</a>. Here
--   <a>True</a> is mapped to a <a>Light</a> line.
simple :: Simple -> Char

-- | Convert a <a>Simple</a> frame to a corresponding <a>Char</a>. Here
--   <a>True</a> is mapped to a <a>Heavy</a> line.
simple' :: Simple -> Char

-- | Generate a <a>Char</a> where turns are done with an <i>arc</i> instead
--   of a corner. This can only be done for <a>Light</a> lines.
simpleWithArc :: Simple -> Char

-- | Converts a given <a>Weighted</a> to the char that can be used to
--   render frames.
weighted :: Weighted -> Char

-- | Convert a <a>Simple</a> frame to a <a>Weighted</a> frame by converting
--   <a>True</a> to the given <a>Weight</a> value.
simpleToWeighted :: Weight -> Simple -> Weighted

-- | Convert a <a>Simple</a> frame to a <a>Weighted</a> frame by converting
--   <a>True</a> to <a>Light</a>.
simpleToLight :: Simple -> Weighted

-- | Convert a <a>Simple</a> frame to a <a>Weighted</a> frame by converting
--   <a>True</a> to <a>Heavy</a>.
simpleToHeavy :: Simple -> Weighted
instance GHC.Show.Show Data.Char.Frame.Weight
instance GHC.Read.Read Data.Char.Frame.Weight
instance GHC.Classes.Ord Data.Char.Frame.Weight
instance GHC.Classes.Eq Data.Char.Frame.Weight
instance GHC.Enum.Enum Data.Char.Frame.Weight
instance GHC.Enum.Bounded Data.Char.Frame.Weight
instance Data.Traversable.Traversable Data.Char.Frame.Parts
instance GHC.Show.Show a => GHC.Show.Show (Data.Char.Frame.Parts a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Char.Frame.Parts a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Char.Frame.Parts a)
instance GHC.Base.Functor Data.Char.Frame.Parts
instance Data.Foldable.Foldable Data.Char.Frame.Parts
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Char.Frame.Parts a)
instance Data.Traversable.Traversable Data.Char.Frame.Vertical
instance GHC.Show.Show a => GHC.Show.Show (Data.Char.Frame.Vertical a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Char.Frame.Vertical a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Char.Frame.Vertical a)
instance GHC.Base.Functor Data.Char.Frame.Vertical
instance Data.Foldable.Foldable Data.Char.Frame.Vertical
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Char.Frame.Vertical a)
instance Data.Traversable.Traversable Data.Char.Frame.Horizontal
instance GHC.Show.Show a => GHC.Show.Show (Data.Char.Frame.Horizontal a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Char.Frame.Horizontal a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Char.Frame.Horizontal a)
instance GHC.Base.Functor Data.Char.Frame.Horizontal
instance Data.Foldable.Foldable Data.Char.Frame.Horizontal
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Char.Frame.Horizontal a)
instance Test.QuickCheck.Arbitrary.Arbitrary Data.Char.Frame.Weight
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Char.Frame.Parts a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Data.Char.Frame.Parts a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Data.Char.Frame.Parts a)
instance GHC.Base.Applicative Data.Char.Frame.Parts
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Char.Frame.Vertical a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Data.Char.Frame.Vertical a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Data.Char.Frame.Vertical a)
instance GHC.Base.Applicative Data.Char.Frame.Vertical
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Char.Frame.Horizontal a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Data.Char.Frame.Horizontal a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Data.Char.Frame.Horizontal a)
instance GHC.Base.Applicative Data.Char.Frame.Horizontal


-- | One can make use of a <a>block of Unicode characters</a> to
--   <i>emulate</i> subscript and superscript. Note that the subscript and
--   superscript will be aligned with the <i>baseline</i> and the <i>cap
--   line</i> respectively, and is thus not equivalent to
--   <tt><a>sub</a>...<a>/sub</a></tt> and
--   <tt><a>sup</a>...<a>/sup</a></tt> in HTML. Furthermore only a small
--   subset of characters is supported.
--   
--   This module allows one to map certain characters to their subscript
--   and superscript counterpart, and furthermore makes it more convenient
--   to transform a number (both positive and negative) to a <a>Text</a>
--   that specifies this number in subscript and superscript.
module Data.Char.Small

-- | Convert a set of characters to their subscript counterpart, given that
--   characters exists.
toSub :: Char -> Maybe Char

-- | Convert a set of characters to their superscript counterpart, given
--   that characters exists.
toSup :: Char -> Maybe Char

-- | Convert a number (positive or negative) to a <a>Text</a> that
--   specifies that number in subscript characters.
asSub :: Integral i => i -> Text

-- | Convert a number (positive or negative) to a <a>Text</a> that
--   specifies that number in superscript characters.
asSup :: Integral i => i -> Text

-- | Format a given <a>Ratio</a> object to a <a>Text</a> value that formats
--   the ratio with superscript and subscript.
ratioToUnicode :: Integral i => Ratio i -> Text
